# 다이나믹 프로그래밍

## 정의 및 설명

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
  - 다이나믹 프로그래밍 / 분할 정복(divid & conquerer) 으로 나뉨
  - 공통점 : 큰 문제를 작은 문제를 나눠서 품
  - 차이점 : 큰 문제를 작은문제를 나눌 때, 다이나믹은 나누었을 때, 작은 문제들이 중복이 가능하고, 분할 정복은 중복이 불가함.
  - 다이나믹 프로그래밍: 40명 => 10,30,15,25로 나누는 것. 
  - 분할 정복 => 40명중 가운데를 기준으로 왼쪽, 오른쪽으로 나누는 것. 중복 불가
- Dynamic Programming의 다이나믹은 아무 의미가 없다.
- 다이나믹은 중복이 발생하니, 중복을 효율적으로 처리하는 것이 관건.

## 속성

- Overlapping Subproblem : 겹치는 부분(작은) 문제 / 작은문제들이 중복되면 다이나믹으로 풀 수 있음. 주로 재귀를 이용해 해결함.
- Optimal Substructure (최적 부분 구조) : 문제의 정답이 작은 문제의 정답을 통해서 구할 수 있다.
  - 최적 부분 구조를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.
    - 10,9,8,7번째 피보나치 수열은 4번째 피보나치 수열을 필요로 한다.
  - 예시 : 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
    - 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.
    - 큰 문제(서울->부산)을 작은 문제(대전, 대구 또는 울산)으로 나눠서 풀수 있기 때문에, 다이나믹 프로그래밍으로 해결 가능.

## 예제

- 피보나치 수

  - Fn = Fn-1+Fn-2
  - 큰 문제를 작은 문제로 나누어서 푼 것.
  - 

  ```java
  int memo[100];
  int fibonacci(int n){
      if(n<=1){
          return 1;
      }
      else{
          if(memo[n]>0){
              return memo[n]; // 시간복잡도 줄이기 위함.
          }
        memo[n] = fibonacci(n-1)+fibonacci(n-2);
          return memo[n];
      } 
  }
  // 한 번만 구하고 이용하자(return)
  ```

  

## 요령

- 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
- Optimal Substructure을 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
- 따라서, 정답을 한 번 구했으면, 정답을 어딘가에서 메모해놓는다.
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
- 메모를 한다고 해서 영어로 Memoization이라고 한다. (cache와 유사)
- 점화식을 정의 한 후, 풀도록 할것. (규칙을 찾는 것이 중요.)
- 수학적 점화식 숙달하고, D(n) = D(n-1)-D(n-2)-D(n-3) 같은 형식에 익숙해질 것.
- 연속,증가,감소가 나올 경우, 마지막 숫자를 생각하며 D[N] [i] 와 같은 이차원 배열을 쓰기도 함.
  - 이때, N은 연속/증가/감소 횟수, i는 마지막 숫자를 가리킴.
  - 이때, D[0],D[1]의 초기화를 잘 생각해서 해야함.
- 점화식과 결과는 맞았을 때, 틀렸다고 하면 끝 숫자를 입력해 int 인지 long인지 확인해 볼 것.

- 점화식이 아닌, 배열을 채워가며 풀 수도 있음.

## 방식

- Top-down (재귀 형식)
- Bottom-up : 문제의 작은 걸 다 풀고 하나씩 큰것들을 풀어나가는 방법. (반복문)
  - Top-down과 Bottom-up의 시간 차이는 알 수 없음.
    - 재귀를 쓸 경우, stack을 쓰기 때문에, stackoverflow 에러가 날 수 있음.(대체로 점화식 오류 / 파이썬의 경우, bottom-up을 쓰는 것을 권장.)
    - 점화식의 편차가 클 경우. 재귀가 더 효율적 일 수 있음.
  - Top-down과 Bottom-up의 용도 차이가 있지만, 우선 능숙하게 하는 것이 목적.