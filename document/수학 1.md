# 수학 1

## 나머지 연산

- 10007로 나눈 나머지 : int 나 long을 초과할 수 있어서 나온 것.
  - 정답을 다 구하고 나머지 연산을 하는 것이 아닌, 정답을 갱신할 때마다 나머지 연산을 수행해야 하는 것
    - (A+B) % M = ((A%M)+(B%M))%M 이기 때문.
    - 곱하기, 더하기는 가능.
    - 뻴셈은 조심할 것. / -2%3= C,JAVA=-2 // PYTHON=1
    - (A%C-B%C+C)%C

## 최대공약수

- 줄여서 GCD라고도 함.

- 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.

- 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B)까지 모든 정수로 나누어 보는 방법이다.

- 최대공약수가 1인 두 수를 서로소라고 한다.

- ```JAVA
  // 기본 방식
  int g = 1;
  for(int i=2;i<min(a,b) ; i++){
      if(a % i ==0 && b % i == 0) {
          g=i;
      }
  }
  ```

- 유클리드 호제법을 이용한 최대공약수 구하기

- GCD(a,b) = a%b =r  = GCD(b,r)

  - ex : GCD(24,16) GCD(16,8) = GCD(8,0) = 8

- r이 0이면 그 때 b가 최대공약수이다.

- ``` JAVA
  // 유클리드 호제법
  int a,b;
  while(b!=0){
      int r = a%b;
      a=b;
      b=r;
  }
  return a;
  ```

   

## 최소공배수

- 줄여서 LCM이라고 한다.
- 두 수의 최소공배수는 두 수의 공통된 배수 중에서 가장 작은 정수
- 최소공배수는 GCD를 응용해서 구할 수 있다.
- 두 수 a,b의 최대공약수를 g라고 했을 때, 최소공배수 l = g*(a/g)*(b/g)이다.
- A*B = GCD * LCM  // LCM = A * B / GCD

## 소수

- 약수가 1과 자기 자신 밖에 없는 수
- N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
- 알고리즘
  - 어떤 수 N이 소수인지 아닌지 판별하는 방법
  - N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법(N이하의 소수 찾기)

``` java
boolean check;
int n;
for(int i=2;i<=n-1;i++){
    if(n%i == 0){
        return false;
    }
}
return true;
```

- N이 소수가 되려면, 2보다 크거나 같고,  N/2보다 작거나 같은 자연수로 나누어 떨어지면 안된다. 

  - N = a * b이고 소수가 아니라면, a=2, b는 N/2가 최대이기 때문이다. 

- ```java
  boolean check;
  int n;
  for(int i=2;i<=n/2;i++){
      if(n%i == 0){
          return false;
      }
  }
  return true;
  ```

- N이 소수가 되려면, 2보다 크거나 같고, 루트 N보다 작거나 같은 자연수로 나누어 떨어지면 안된다.

  - N이 소수가 아니라면, N = a * b 로 나타낼 수 있다.
  - n * n>=a, n * n<=b이기 때문이다.

- ```java
  boolean check;
  int n;
  for(int i=2;i*i<=n;i++){
      if(n%i == 0){
          return false;
      }
  }
  return true;
  ```

- 에라토스테네스의 체

  -  1부터 N 까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.
  - 2부터 N까지 모든 수를 써놓는다.
  - 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
  - 그 수는 소수이다.
  - 이제 그 수의 배수를 모두 지운다.
  - N=100이라면 11의 배수는 이미 지워져 있기 때문에, 소수 7까지 관여하면 된다. 11 * 11 = 121전까지 숫자는 모두 소수가 확정된 셈.

```java
int prime[100];  // 소수 저장
int pn = 0; // 소수의 개수
bool check[101]; // 지워졌으면 true
//진짜로 지우면 시간 걸려서 true false로만 확인.
int n = 100;
for(int i=2;i<=n;i++){
    if(check[i] == false){
        prime[pn++] = i;
        for(int j =i*i; j<=n ; j+=i){
            check[j] =true;
        }
    }
}
```

## 소수 구하기 - 골드바흐의 추측

- 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.
- 위에 문장에 3을 더하면
- 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.
  - 2+3 =5 / 짝수+3 = 홀수 / 3+ 두 소수의 합 = 세 소수의 합
- 아직 증명되지 않았지만, 10의 18승 이하에서는 참인 것이 증명되어 있다.



- 백만 이하의 짝수에 대해서 골드바흐의 추측을 검증하는 문제
- N = a+b
- 에라토스테네스의 체를 이용하면 범위에 있는 소수를 구해서 저장. 저장된 모든 소수는 a, N-b가 소수인지 아닌지 검색.
- 루트 N을 사용해도 되나 에라토스테네스의 체를 이용하면 쓸 필요 없음.
- check[N-b] == false;

## 팩토리얼

- N! = 1 * 2 * ... * N
- 팩토리얼은 매우 큰 값
- 팩토리얼 0의 개수 : 2와 5의 개수를 찾아야함.
  - 5의 개수가 항상 2의 개수 보다 적기 때문에, 5의 개수만 세어주면 된다.
  - 0의 개수 : 5로 계속 나누어보기.
  - 25,50,75,100은 5가 두 개씩 들어간다.
  - 100/5 = 20 + 100/25 = 4  ==> 20+4=24;
  - 조합의 경우, 2가 5보다 많을 수도 있음.

