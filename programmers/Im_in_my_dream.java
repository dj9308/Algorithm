package practice;

//생각의 흐름
//
//완전탐색 각이다. 
//3단 고음을 하려면 반드시 맨 앞에 *이 와야하고 맨 뒤에는 ++가 있어야함.
//따라서 이 규칙을 토대로 구성된 문자열을 역추적해가며 전체탐색을 진행하기로.
//처음 음역 1로 시작해서 n을 만드는 거라 n을 3으로 나누거나 1을 빼서 1을 만들 수 있으면 답이 하나 증가하는 것.
// stackoverflow => ???????????????????????????????????????????????????????????
// 조건부를 하나 넣어야할것같은데 도무지 생각이 안남.
// 그래서 구선생님 찾다가 결국 다른사람 답이 본 답과 비슷한 게 있어서 조합해본결과 문제를 찾음.

//1을 빼는 것은 +의 개수를 증가시키는 것을 의미. 이건 *++ 형태에서 +의 개수는 *의 두 배가 되며 규칙에 맞게 문자열을 배치했다면 이 등호는 반드시 맞음.
//
//따라서 +문자를 증가시킬 때마다 가능한 *의 개수의 2배가 +의 개수를 넘어설 수 없다면 +의 수가 너무 많은 것이므로 앞으로 더 이상 진행할 필요가 음슴.
//이생각이 안나서 20분 정도 지체
//테스트케이스 완료인데 시간이 무슨 7000이나 되는가....

//느낀점 : 문제만 제대로 이해하고 수학적으로 조금 생각하면 나름 쉬운문제.
//근데 문제이해만 30분 걸림ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 시부렐레
//뭔가 완전탐색이나 탐욕법같은건 아이큐테스트같은 느낌.
//
//도대체 시간을 줄이려면 얼마나 더 자주 봐야할까 아직 한참 멀었다.
//이번년도 카카오 코테는 두문제 푸는 것이 목표. 꾸준하게. 이제 내 별명은 설꾸준이다.
//총 소요시간 : 1시간 30분

public class Im_in_my_dream {

	public static void main(String[] args) {
		int n = 2147483647;
		System.out.println(solution(n));
	}

	public static int solution(int n) {
	      int answer = 0;
	      answer = back(n-2, 2);
	      return answer;
	   }

	    public static int back(int n, int num) {
	    	
	        if(n == 3) {
	        	if(num ==2) {
	        		return 1;
	        	}else {
	        		return 0;
	        	}
	        }
	        
	        if(n < 1 || 2*Math.log10(n)/Math.log10(2) < num) return 0;
	        
	        int ret = 0;
	        
	        if(n%3 == 0 && num >= 2)
	            ret += back(n/3, num-2);

	        ret += back(n-1, num+1);

	        return ret;
	        

	    }

}
